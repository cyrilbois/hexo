---
title: 记录一次升级工程导致的线上问题
date: 2022-07-25 21:00:57
tags:
  - 踩坑
categories:
  - 踩坑
---

### 背景

我正在盯着屏幕思考如何在本地环境调用微信jssdk相关接口时，突然我司线上反馈群中，一个运营同事抛出来一个线上故障

“有个用户说访问我们的App中商店模块，一直处于loading加载状态，网页一直加载不出来”

由于前段时间，我对于该模块做了整体上的项目升级，但是每次上线之前，我们的测试都已经对核心的模块都进行了黑白盒测试，所以理论上不会出现该问题才对。

这个时候，安卓同事用一台机器复现了该场景，通过chrome调试工具，发现该网页的控制台中报了如下的错误

![image-20220728204554128](https://show.newarray.vip/blog/bug-babel.png)

当我看到这个报错的时候，我第一时间想到的就是，低版本浏览器对于ES6代码不支持...

### 思考

虽然看起来，这个报错，感觉是低版本不支持ES6代码（实际上就是这个问题），但是我自己回想了下，该项目是用vue-cli3搭建的，里面应该已经默认配置了babel相关的代码转换，不是说好了开箱即用吗😂

于是乎，我去网上搜了下，竟然真的发现了有不少同学，也遇到了同样的这个问题，虽然报错各异，但是总结起来就是**浏览器不认识你的代码**

紧接着，我发现了一个让我为之震惊的一句阐述：vue-cli3 中自带 babel-polyfill ，会将[es6](https://so.csdn.net/so/search?q=es6&spm=1001.2101.3001.7020)语法转化成es5语法。但是如果**依赖**中有es6， polyfill是不能检测出来的。具体可以看[ vue-cli3项目浏览器兼容问题，在低版本系统中白屏](https://blog.csdn.net/weixin_41767649/article/details/121681886)

看到这，我结合之前的学习经历思考了一下，难道webpack不是从入口文件处，递归的去寻找各个模块，然后通过babel-loader进行转义的吗，依赖的文件中的js，按理说也应该被转成低版本兼容的代码才对...

### 寻找真相

带着疑惑，我扒开了vue-cli官网，关于[浏览器兼容性](https://cli.vuejs.org/zh/guide/browser-compatibility.html#polyfill)这一章，其中的表述有这样一段话：

> 默认情况下，它会把 [`useBuiltIns: 'usage'`](https://new.babeljs.io/docs/en/next/babel-preset-env.html#usebuiltins-usage) 传递给 `@babel/preset-env`，这样它会根据源代码中出现的语言特性自动检测需要的 polyfill。这确保了最终包里 polyfill 数量的最小化。然而，这也意味着**如果其中一个依赖需要特殊的 polyfill，默认情况下 Babel 无法将其检测出来。**

在我看来，这个就是不臭不香的解释与实现，既然已经配置了`useBuiltIns: 'usage'`，难道不是根据我项目用到的ES6代码进行转换吗，为啥还要区分**源代码**和**依赖代码**？？？

于我而言，我实在不理解一个问题，依赖代码，就不属于源码了？

这里我想解释一下，依赖代码，就是node_modules中的包，所以我翻译上面的引文就是：

> 如果你用了A包中的某个js文件，但是这个文件中，有应用ES6代码，那么不好意思，babel大爷我是不认你这个文件的，也就自然不会帮你把ES6代码转ES5，我也是为你好，因为一般情况下，应用的包中的代码，都已经是被babel+webpack编译过一次的，可以直接使用的了。你不按规矩来，怪我喽？

既然找到了问题的根源所在，那就看看怎么解决它，好在vue-cli还算比较贴心，提供了一个[transpiledependencies](https://cli.vuejs.org/zh/config/#transpiledependencies)选项，明确的告诉脚手架

> 我这个包里面可能用了一些高版本的js语法，劳烦您在打包的时候，也让babel_loader帮我转义一下呗

### 解决

该选项虽然看官网阐述，支持多种配置，但是大部分的场景下，还是传递一个数组，数组中通过正则，标明需要被处理的包名

```javascript
transpileDependencies: [/[/\\]node_modules[/\\]butter(.*)/]
```

上面这样配置，就是明确地告诉脚手架，对于我源码中引入的包名为butter开头的包，其中的文件，你都捎带着帮我处理下，转成低版本的。

### 结果

通过上述配置后，提交代码，通过github action编译之后，分别推送到了生产和测试环境，通过小秘密武器，让之前报错的手机，代理到测试环境，发现果然能正常访问了...

最后，大吉大利，上线。

### 总结

通过这个小问题，我有以下一些感悟

- 现在工具脚手架特别多，配置项也各异，作为开发者，虽然用起来很爽，但是出了问题，一定要知道如何去解决，这就需要你对webpack、babel都有一定的理解和实践
- 线上出现问题后，不要慌张，先定位问题，再解决问题，当然我觉得自己还是要平时多关注下sentry监控平台，虽然像这次的错误，是由于用户安卓浏览器版本太低了，测试在上线前并不一定能够复现或者遇到这种问题
- 其实在我看来，有些问题，忽略也是一种更好的选择，就比如这个问题，因为需要被处理，那么babel处理过后的文件，打包到chunk中，肯定会造成更大的体积，也会带来更大的请求资源带宽，所以要学会懂得取舍