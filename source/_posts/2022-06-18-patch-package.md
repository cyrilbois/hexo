---
title: patch-package
date: 2022-06-18 19:07:01
tags:
  - npm
  - node
categories:
  - npm
---



这是一款比较有意思的`npm`包，举个场景，可能更好理解：

小丁在开发中用了别人写的一个`npm`包，正当用的起劲的时候，发现了源代码中有一个小错误影响了你的开发进度，往往这个时候，我们的第一反应是如何联系到该包作者，让作者进行修复后，重新发布个版本。一般这种场景下，我们都是通过github issue给对方提出问题，静待回复...

又或者是fork一下仓库，自己修改错误后重新编译一遍，自己发个包...

但是无论是哪种场景，可能都不太能够再第一时间解决问题...

{% img https://show.newarray.vip/excalidraw/oh-my-god.png 200 %}

这个时候我们可能会想，有没有什么办法，可以在我们构建之前，先去修复下别人出现问题的包中的代码

虽然这个是行的通的，但是只能本地来这样操作。因为往往我们的项目构建，是处于持续集成中的，可以说是一个黑盒操作。这个构建的动作，也就是我们常用的`npm run build...`


我也是在做aliyun-cdn-sdk这个库的过程中，遇到了这个问题，当时跑去别人的仓库中看有没有人提issue，结果还真发现一个有缘人和我遇到了同样的问题，像他一番请教后，我才知道了这么个有意思的包，接下来记录一下该包的用法和实现思路（个人理解）

### 使用步骤



1.首先在你的项目中安装patch-package

```javascript
npm i -D patch-package
````

2.修复别人包中错误的代码

这里其实不太好理解，我们应该怎么修复，或者说是修复哪个文件呢。这个得先需要你去看下出错这个包文件中的package.json文件，看下该包的默认引入路径文件是哪个，也就是看`main:'xxxx'`

如果这个文件指向一个不需要编译的简单文件的话，那么你直接修复他的代码，改成正确的即可

更常见的是，main指向的默认导出文件是经过编译的，也就是经过webpack、rollup等构建工具处理过的，这个时候，可能我们不太方便去修改，因为里面已经揉杂了很多东西。这个时候，往往需要我们先去把别人的仓库代码clone下来，改掉没编译前的错误。然后自己本地进行构建

这个时候构建出来的代码，假设是常见的`dist/index.js`吧，已经是正确的文件了。你需要做的，就是用你本地的文件，替换掉你项目中出错的那个文件


3.执行脚本
```javascript
npx patch-package xxx // xxx就是被你修复的那个包
```

执行完该操作后，你仓库跟目录会出现一个patches文件夹，里面会生成一个 `xxx+版本号.patch`文件，而这个文件中记录的东西，就是你的正确代码和原来错误代码的差异，如下图，可以看出来，它大致表明了要修复文件的位置，修复的行数，以及修复的具体内容等

{% img https://show.newarray.vip/carbon/patch-package.png %}

4.配置项目脚本

上面的文件有什么用呢，或者是什么时候用呢？这就需要我们在用到该包的自己项目中，配置一个特殊的脚本，位于package.json中

```javascript
"scripts": {
    "build": "xxx",
    "dev":'xxx',
    "postinstall": "patch-package"
  },
```
这行代码的作用就是我们在该项目中执行`npm install`的时候，会执行该脚本，而该脚本，正是会使用`patch-package`这个工具包，而该包又会根据我们项目根目录patches文件夹中提到的上述那个xxx.patch文件，进行问题的修复，修复完之后的包，就是能够正常使用的包了

> 如果你想开发npm包，让其他人用的话，不管是全局包，还是项目中用到的那些包。那么我们大概率要去好好看看npm官方的一些配置项的含义和用法。你不知道你有没有想过一件事，那就是为啥我们可以在自己的设备中以npm install xxx -g安完某个包之后，就能全局使用呢？

利用好npm赋予我们的能力，我们可以写出一些很有意思的工具库，比如安装这个包的时候，触发postinstall脚本，执行node脚本，生成接口api。或者是根据项目结构，生成一些后期访问项目的路径等等。






