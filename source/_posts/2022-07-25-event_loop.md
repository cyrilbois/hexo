---
title: Event Loop
date: 2022-07-25 21:00:57
tags:
  - javascript基础知识
  - 宏任务、微任务
  - 事件队列
categories:
  - javascript
---
### 单线程

javascript是一门单线程语言，单线程如果不做任何语言设计的话，是会导致阻塞的。比如用户发起了一个请求，请求在3秒之后，返回结果。阻塞的结果就是这3秒内，浏览器会表现出假死状态，这显然是不合理的。

结合我们的实际使用场景，明显可以看出来，语言的设计者，设计出了一种模式（非阻塞），可以避免这种缺陷。

而实现非阻塞，就是利用了事件循环（EventLoop）

### Event Loop

在javascript中，任务的类型分为同步任务以及异步任务，同步任务会按照顺序，在执行栈中执行。遇到异步任务的时候，线程并不会等待异步任务的返回结果，而是将这个事件挂起，继续执行执行栈中的同步代码。当异步事件返回结果，将它（一般指回调函数）放到事件队列中，被放入事件队列不会立刻执行起回调，而是等待当前执行栈中所有同步任务都执行完毕，主线程处于空闲状态时会去查找事件队列中是否有任务，如果有，则取出排在第一位的事件，并把这个事件对应的回调放到执行栈中，然后执行其中的同步代码。

<!-- more -->

### 宏任务与微任务

异步任务分类这两类，他们的区别在于事件循环机制中，执行的机制不同（顺序）。

当执行栈中的同步任务全部执行完成之后，会在事件队列中先取出所有的微任务执行，当所有的微任务执行完成之后，才会执行宏任务。所以可以看出来，微任务的**优先级**是要高于宏任务的。

在javascript中，常见的宏任务

- script代码（script代码块）
- setTimeout/setInterval
- I/O
- ajax
- UI交互

常见的微任务

- new Promise().then
- MutationObserver

**注：实例化promise的过程其实是一个同步的代码，不要把它当作异步的任务**



```javascript
function a() {
    b();
    console.log('a');
}
function b() {
    console.log('b')
    setTimeout(function() {
        console.log('c');
    }, 2000)
    setTimeout(function() {
        console.log('d');
    }, 1000)
}

new Promise((reslove)=>{
    console.log('e')
    reslove()
})
.then(res=>{
    console.log('f')
})
a()
```

通过上面的几点规则，就可以很容易的知道上面的代码片段执行的结果是：e,b,a,f,d,c

解读：

- 代码从上往下解析执行
- 首先由于实例化promise的过程是同步的，所以首先打印e
- promise.then中的代码是属于异步任务（微任务），所以会被放到事件队列中
- 然后执行a方法，a方法中又执行b方法，所以打印b
- 接着遇到了两个定时器函数，属于宏任务，所以也会被放到事件队列中
- b函数被推出执行栈后，紧接着会去打印a
- 这时候，所有的同步代码都执行完毕了，要开始从事件队列中取已经完成的异步任务，而异步任务又是先执行微任务，再执行宏任务，所以先后打印f,d,c

### 参考

[(3) JavaScript中的Event Loop（事件循环）机制](https://segmentfault.com/a/1190000022805523)

