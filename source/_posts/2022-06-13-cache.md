---
title: cache
date: 2022-06-13 18:14:43
tags:
  - cache
  - cdn
  - 浏览器缓存
categories:
  - 缓存
---

### 缓存的一些知识点

缓存在前端领域是不可或缺的一部分，在实际的工作中也会经常遇到下面的场景

> 明明最新的文件我在服务器上面已经更新了，但是为啥客户端访问的资源文件还是旧的

我在部署 hexo 博客的过程中，就遇到了这个问题。因为我的资源文件是部署在 oss 中的，同时对该 bucket 也配置了 cdn 加速和 cdn 缓存自动刷新的设置。但是当我重新部署后，通过浏览器访问静态资源文件，依然是旧的。

其实问题出现在了客户端缓存中，这里的客户端，对于前端来说，就是浏览器

<!-- more -->

### 浏览器缓存

浏览器缓存分为协商缓存和强缓存，强缓存的优先级高于协商缓存

1.**强缓存**：浏览器在加载资源时，首先会先根据首部信息（Expires 和 Cache-Control）来判断是否命中强缓存，如果命中，直接从浏览器缓存中将资源取出来，不会发送请求到服务器。

强缓存一般主要用两个字段来进行控制`cache-control` `expires`

比如：

```javascript
 cache-control: max-age="3600" // 服务器响应客户端第一次请求时，会明确的告诉客户端（浏览器），在一个小时之内（3600秒），再次访问该资源，直接用缓存即可
```

打开控制台`network`模块，查看`size`这一列，看到字眼形如`from disk cache` `from memory cache`的，表示命中了强缓存，此时的响应状态码为`200`

2.**协商缓存**：在没有命中强缓存的前提下，浏览器会发送一个请求（带有一些跟协商缓存有关的首部）给服务器，服务器根据这些首部信息和所请求资源目前的一些 header 信息来比较验证这个资源是否命中协商缓存，如果命中了，服务器会将这个请求返回，但是并不会返回这个资源的数据，而是告诉浏览器，资源没有变化，可以直接从浏览器缓存中加载这个资源。

协商缓存一般会在请求头中以下列字眼标识

```javascript
  cache-control: no-cache
```

当命中协商缓存的时候，服务器在第一次响应时，在响应头上加上资源文件的最后修改时间`Last-Modified`或者是强标识符`ETag`

```javascript
Last-Modified: Mon, 8 Oct 2021 06:35:57 GMT // 表示该文件的最后修改时间是Mon, 8 Oct 2021 06:35:57 GMT
```

客户端再次请求的时候，会在请求头中加上这样的字段

```javascript
If-Modified-Since: Mon, 8 Oct 2021 06:35:57 GMT
```

询问服务端，该资源在 Mon, 8 Oct 2021 06:35:57 GMT 之后是否修改过，如果修改的话，就返回最新的资源，并在响应头上加伤最新的`Last-Modified`。如果在这之后并没有修改过该文件的话，那么直接返回状态码`304`，明确告知浏览器去缓存里面拿内容即可

`Etag`的作用和`Last-Modified`差不多，只不过更加准确而已

### hexo 浏览器缓存解决方案

在我的这个部署过程中，发现虽然我已经部署了最新的静态资源，但是由于客户端缓存的存在，导致浏览器中请求得到的资源是命中缓存中的，为了避免这个问题，在`deploy.yaml`中，我添加了一步，让浏览器在请求样式文件时，添加上一个`query`即可，这样每次部署后，样式文件就会去请求最新的资源。

```javascript
 - name: Add Css Version Avoid Browser Cache
        run: |
          for file in `find static -name "index.html"`;do sed -i "s#css/style.css#css/style.css?version=$(date "+%y%m%d").$GITHUB_RUN_NUMBER#g" $file;done
```

而我们使用前端脚手架搭箭的项目，可以利用`webpack`构建出带 hash 的静态文件，这样就能完美的解决这个问题。

### 关于阿里云 cdn 缓存的一些使用心得

- 一般情况下，我们会通过设置 cdn 资源缓存过期时间，这个时间的作用是明确的告诉 cdn 到了我们设置的时间后，该节点的资源已经失效了，需要重新去源站获取最新的资源。
- 为了避免更新资源后，客户端仍然用的是缓存。可以通过给 cdn 资源修改 http 响应头实现

```javaScript
// 新增
Cache-Control: max-age=0,no-cache; // 这个就是告诉客户端，cdn上的资源过期时间为0，每次客户端请求资源的时候，都需要询问下cdn该资源有没有过期
// 删除
删除响应头Last-Modified // 删除这个响应头的原因是为了配上上面的设置，通过Etag唯一标识符实现协商缓存，判断资源是否过期

```

开启了协商缓存，通过 Etag 实现，也就是每次我们访问资源的时候，询问下 cdn 服务器，该资源有没有过期，如果过期的话，就去取源站最新的资源再返回给客户端。

- 大致意思就是我们的每个文件，都有一个字符串唯一标识符，当请求头中中`If-None-Match`不等于该资源的 etag 时，就代表该资源被更新过，cdn 需要去源站拿最新的资源给客户端，否则就代表源站的资源仍未更新，可以直接使用。
